1.注解：
	格式：@interface 注解名{}
	
	作用：
		编译检查
		替代配置文件
		定义注解（元注解：注解上的注解）
		分析代码（用到反射）
	
2. java中的3个注解（了解）：
	@override: 声明该方法是从主类上继承过来的，执行编译期的检查
	@SuppressWarnings("all"): 抑制警告
	@Deprecated: 声明该方法或者字段不赞成使用
		过时了
		有可能有一些bug

3.  自定义注解：（理解）
		注解本质是一个接口，接口中可以有常量和注解方法（注解属性）
		抽象方法在注解中 称为注解属性
		
		注解类型：
			基本类型
			自己查吧
		 
		赋值的格式：
			@注解名（属性名=属性值）
			若注解类型为数组 且只有一个值的时候 可以有两种写法
				方式1：
					属性名={值}
				方式2：
					属性名=属性值
			若属性名为value的时候 且只需要为这个value属性赋值的时候  value可以省略
			
		元注解：
			定义在注解上的注解
				@retention  规定注解保留到什么阶段
					SOURCE 只在代码保存 字节码文件中删除
					CLASS  在代码和字节码文件中保留
					RUNTIME  所有阶段都保留
					
				@Target
					TYPE : 作用在类 接口等上面
					METHOD ： 作用在方法上面
					FIELD： 作用在字段上面
					
4. 案例-获取连接的工具类  
		通过配置四个参数  
		详见JDBCInfo 注解
		
5. 案例2-完成文件上传
		
	//////////////////////
	可以用  1.servlet3.0: 
			2.commons-fileupload
			3.框架
	
	实现，
	////////////////////////
	
	servlet3.0: 
		支持注解开发，没有web.xml  
			在servlet 
			  filter
			  listener
			上添加@webServlet(patterns="")
		内嵌了文件上传功能
		
	/////////////////////////\
 文件上传
	浏览器端要求：
		表单提交方式必须是post
		必须有一个文件上传组件  <input type= "file" name="" />
		必须设置表单的enctype = multipart/form-data
	服务器端的要求：
		servlet3.0中
			需要在servlet中添加注解
				@MultipartConfig
			接收普通上传组件  （除了文件上传组件）：request.getParameter()
			接收文件上传组件 ：request.getPart("name属性值")；
				getName(): 获取的name的属性值
			获取文件名：
				part.getHeader("Content-disposition"): 获取头信息 然后截取
	
		
	注意：
		1. 名字重复 否则会覆盖 ---解决：随机名称
				在数据库中提供两个字段  一个存放真实名称   1.jpg 另一个字段存放文件存放路径： g:/sadgjgh.jpg
			随机名称：
				UUID
				时间戳
				
		2. 文件安全
			重要的文件存放在web-inf 或者 meta-inf 或者 服务器创建开一个路径
			不是很重要的文件 项目下
		3.文件存放目录
			方式1：日期
			方式2：用户
			方式3：文件个数
			方式4：随机目录
			
/////////////////////////////////
6. 类加载器：
	类加载：
		编写的.java 文件， jvm会将其变成.class文件，该文件要想运行，必须加载到内存，然后会生成一个对象 .Class对象，
	类加载器层次结构：
		引导类加载器 rt.jar
		扩展类加载器 ext/*.jar
		应用类加载器  自己编写的类
	全盘负责委托机制：
		当一个类运行的时候，有可能有其他类，应用类加载器询问扩展类加载器：你加载过这个类吗？
		扩展类加载器再向上问（引导类加载器）：你加载过这个类吗？
		引导类加载器：我查查 ，有一个我负责，我加载
		扩展类加载器：接下来我查，有几个是我查，有几个是我负责的，我加载，还有几个类我已经加载完了，你可以直接使用
		应用类加载器 ：收到了 剩下的我来加载

7. 案例3-统一编码

动态代理：
	在项目运行的时候才创建一个代理对象，对方法进行增强，（控制）
	方式1：
		jdk中proxy类，前提：实现接口
	方式2：
		spring 中cglib 前提：继承类
		
	动态代理在内存中创建一个代理对象
		Object	Proxy.newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)
		
		参数说明：
			ClassLoader：代理对象类加载器  一般我们使用的是被代理对象的类加载器
			Class[] :代理对象需要实现的接口 一般我们实现的是被代理对象所实现的所有接口
			InvocationHandler中只有一个方法：
				Object invoke (Object proxy,Method method,Object[] args)
				参数说明：	
					proxy:代理对象
					method:当前执行的方法
					args:当前方法执行的时候 所需要的参数
					返回值：就是当前method对象 执行的返回值

（静态代理day16）
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	